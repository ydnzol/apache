<?xml version="1.0" encoding="iso-2022-jp"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja"><head><!--
        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
              This file is generated from xml source: DO NOT EDIT
        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      --><title>停止と再起動 - Apache HTTP サーバ</title><link href="./style/css/manual.css" rel="stylesheet" media="all" type="text/css" title="Main stylesheet" /><link href="./style/css/manual-loose-100pc.css" rel="alternate stylesheet" media="all" type="text/css" title="No Sidebar - Default font size" /><link href="./style/css/manual-print.css" rel="stylesheet" media="print" type="text/css" /><link href="./images/favicon.ico" rel="shortcut icon" /></head><body id="manual-page"><div id="page-header"><p class="menu"><a href="./mod/">モジュール</a> | <a href="./mod/directives.html">ディレクティブ</a> | <a href="./faq/">FAQ</a> | <a href="./glossary.html">用語</a> | <a href="./sitemap.html">サイトマップ</a></p><p class="apache">Apache HTTP サーバ バージョン 2.0</p><img alt="" src="./images/feather.gif" /></div><div class="up"><a href="./"><img title="&lt;-" alt="&lt;-" src="./images/left.gif" /></a></div><div id="path"><a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP サーバ</a> &gt; <a href="http://httpd.apache.org/docs-project/">ドキュメンテーション</a> &gt; <a href="./">バージョン 2.0</a></div><div id="page-content"><div id="preamble"><h1>停止と再起動</h1>
    <p>この文書では Unix に類似したシステムでの
    Apache の停止と再起動について扱っています。Windows
    ユーザ (Windows で Apache を使う場合) は、<a href="platform/windows.html#signal">実行中の Apache
    にシグナルを送る</a>もご覧下さい。</p>
</div><div id="quickview"><ul id="toc"><li><img alt="" src="./images/down.gif" /> <a href="#introduction">イントロダクション</a></li><li><img alt="" src="./images/down.gif" /> <a href="#term">急な停止</a></li><li><img alt="" src="./images/down.gif" /> <a href="#graceful">緩やかな再起動</a></li><li><img alt="" src="./images/down.gif" /> <a href="#hup">急な再起動</a></li><li><img alt="" src="./images/down.gif" /> <a href="#race">付録: シグナルと競合状態</a></li></ul></div><div class="top"><a href="#page-header"><img alt="top" src="./images/up.gif" /></a></div><div class="section"><h2><a name="introduction" id="introduction">イントロダクション</a></h2>
    <p>たくさんの実行形式 <code>httpd</code> がシステム上で
    実行されているのに気が付くでしょうが、シグナルを送るのは
    親プロセスだけで、それ以外の個々のプロセスには
    シグナルを送らないで下さい。その親プロセスの pid は
    <code class="directive"><a href="./mod/mpm_common.html#pidfile">PidFile</a></code>
    に書かれています。これはつまり、親以外のプロセスに
    シグナルを送る必要すらない、ということです。
    親プロセスに送ることができる 3 種類のシグナルがあります:
    <code>TERM</code>, <code>HUP</code>, <code>USR1</code>
    です。これらの説明については続きをご覧下さい。</p>

    <p>親プロセスにシグナルを送るには、
    次のようなコマンドを発行して下さい:</p>

<div class="example"><p><code>kill -TERM `cat /usr/local/apache/logs/httpd.pid`</code></p></div>

    <p>これの実行状況は次のコマンドで読むことができます:</p>

<div class="example"><p><code>tail -f /usr/local/apache/logs/error_log</code></p></div>
    <p>ここに挙げた例は、各自の
    <code class="directive"><a href="./mod/core.html#serverroot">ServerRoot</a></code>
    と
    <code class="directive"><a href="./mod/mpm_common.html#pidfile">PidFile</a></code>
    の設定に適合するように適宜修正して下さい。</p>

    <p><a href="programs/apachectl.html">apachectl</a>
    と呼ばれるシェルスクリプトで、Apache にシグナルを送る手順を
    自動化することができます。このスクリプトの詳細に関しては、
    <a href="invoking.html">Apache の起動</a>の文書をご覧下さい。</p>
</div><div class="top"><a href="#page-header"><img alt="top" src="./images/up.gif" /></a></div><div class="section"><h2><a name="term" id="term">急な停止</a></h2>

<dl><dt>シグナル: TERM</dt>
<dd><code>apachectl stop</code></dd>
</dl>

    <p><code>TERM</code> シグナルを親プロセスに送ると、
    即座に子プロセス全てを kill しようとします。
    子プロセスを完全に kill し終わるまでに数秒かかるかもしれません。
    その後、親プロセス自身が終了します。
    処理中のリクエストは全て停止され、もはやリクエストに対する
    応答はされません。</p>
</div><div class="top"><a href="#page-header"><img alt="top" src="./images/up.gif" /></a></div><div class="section"><h2><a name="graceful" id="graceful">緩やかな再起動</a></h2>

<dl><dt>シグナル: USR1</dt>
<dd><code>apachectl graceful</code></dd>
</dl>

    <p>親プロセスは <code>USR1</code> シグナルを受け取ると、
    子プロセスに現在のリクエストの処理の後に終了する
    (あるいは何もしていなければすぐに終了する)
    ように<em>助言</em>します。
    親プロセスは設定ファイルを再読込して、ログファイルを開き直します。
    子プロセスが徐々になくなるに従って、
    新しい<em>世代</em>の設定による子プロセスに置き換えていきます。
    そして、これらが新たなリクエストに即座に応答し始めます。</p>
    <div class="note">特定のプラットホームでは USR1 を緩やかな再起動のために
    使うことができませんが、代わりのシグナル
    (例えば WINCH) が使用できるでしょう。
    <code>apachectl graceful</code>
    というコマンドはプラットホームに合ったシグナルを送ります。</div>

    <p>このコードは常に
    MPM のプロセス制御ディレクティブの設定を重視しますので、
    クライアントのリクエストを扱うプロセスとスレッドの数を再起動の処理中も
    適切な値に維持されます。。また、次のようにして
    <code class="directive"><a href="./mod/mpm_common.html#startservers">StartServers</a></code>
    を守ります:
    少なくとも 1 秒後に <code class="directive"><a href="./mod/mpm_common.html#startservers">StartServers</a></code> 個の新しい子プロセスが
    生成されていなければ、その数になるように適宜プロセスを生成します。
    この挙動は現在の負荷に対して適切な子プロセスの数と
    <code class="directive"><a href="./mod/mpm_common.html#startservers">StartServers</a></code> パラメータでの
    希望の数の両方を維持しようとしています。</p>

    <p><code class="module"><a href="./mod/mod_status.html">mod_status</a></code> を
    使用している場合は、<code>USR1</code> シグナルが送られた際に
    サーバ統計がゼロに<strong>設定されない</strong>ことに
    注意してください。
    サーバが新しいリクエストに応答不能な時間を最小にするように
    (リクエストは OS によってキューに追加されるので絶対に紛失はしません)、
    また同時に、希望のチューニングパラメータを守るように
    コードは書かれています。
    このようにするために、世代をまたがった全子プロセスの追跡に使われている
    <em>スコアボード</em>を維持しなければなりません。</p>

    <p>status モジュールは、緩やかな再起動以前から開始して
    リクエストに応答し続けている子プロセスを特定するために、
    <code>G</code> を使うこともします。</p>

    <p>現在、<code>USR1</code> を使うログ移動スクリプトでは、
    再起動前の子プロセスがログを書き終わったことを確証する方法が
    ありません。古いログに対して何かする前に、
    <code>USR1</code> シグナルを送った後いくらか適当な時間待つことを
    提案します。例えば、帯域の狭い通信路のユーザのリクエストのほとんどが 10 
    分以下で完了しているということが分かっていれば、
    古いログに何かする前に 15 分待つということです。</p>

    <div class="note">再起動時に設定ファイルに誤りがあると、
    親プロセスは再起動せずにエラーとともに終了します。
    緩やかな再起動の場合は、親プロセスが終了した後でも子プロセスが
    実行されたまま放置されたりもします。
    (最後のリクエストを処理した後「緩やかに終了」する
    子プロセスとなります。)
    サーバを再起動する際に、これが問題になるかもしれません
    -- サーバは listen するポートにバインドできないかもしれません。
    再起動する前に、設定ファイルの構文を <code>-t</code>
    コマンドライン引数
    (<a href="programs/httpd.html">httpd</a> をご覧下さい)
    を使って検証することができます。
    設定ファイルの意味的な内容を構文と同様に検証したい場合は、
    非 root ユーザで httpd を起動しようとすればわかります。
    もしエラーがなければ、ソケットやログを開こうとして
    root でないため
    (もしくは httpd が既に必要なポートにバインドしているため)
    に失敗するでしょう。
    これ以外の理由で起動に失敗したのであれば、
    それは設定ファイルのエラーで、
    緩やかな再起動を行う前にその誤りを修正しなければなりません。</div>
</div><div class="top"><a href="#page-header"><img alt="top" src="./images/up.gif" /></a></div><div class="section"><h2><a name="hup" id="hup">急な再起動</a></h2>

<dl><dt>シグナル: HUP</dt>
<dd><code>apachectl restart</code></dd>
</dl>

    <p><code>HUP</code> シグナルを親プロセスに送ると、
    <code>TERM</code> と同様に子プロセスを kill しますが、
    親プロセスは終了しません。
    設定ファイルを再読込して、ログファイル全てを開き直します。
    その後、新しい子プロセスを起動して応答を続けます。</p>

    <p><code class="module"><a href="./mod/mod_status.html">mod_status</a></code>
    を使っている場合は、<code>HUP</code> が送られた場合に
    サーバ統計がゼロに設定されることに注意してください。</p>

    <div class="note">再起動時に設定ファイルに誤りがあると、
    親プロセスは再起動せずにエラーとともに終了します。
    これを避けるには次の方法をご覧下さい。</div>
</div><div class="top"><a href="#page-header"><img alt="top" src="./images/up.gif" /></a></div><div class="section"><h2><a name="race" id="race">付録: シグナルと競合状態</a></h2>

    <p>Apache 1.2b9 以前は、再起動や停止のシグナルを含む<em>競合状態</em>
    (競合状態を簡単に説明すると: タイミンにグよる問題で、
    具合の悪い時間帯にちょうど何かが起こると予想外の動作をする
    ようなことを指します) がありました。
    「正しい」機能を持っているアーキテクチャでは、できるだけ
    このようなことが起こらないようにしています。
    しかし、ある種のアーキテクチャでは競合状態は未だ確実に起こりえる
    ということに注意してください。</p>

    <p>ディスク上で
    <code class="directive"><a href="./mod/mpm_common.html#scoreboardfile">ScoreBoardFile</a></code>
    を使用しているアーキテクチャでは、
    潜在的にスコアボードが壊れる可能性があります。
    スコアボードが壊れた場合は、
    "bind: Address already in use" (<code>HUP</code> 後) や
    "long lost child came home!" (<code>USR1</code> 後)
    といった結果になります。
    前者は致命的なエラーですが、
    後者はスコアボードスロットを失うだけです。
    ですから緩やかな再起動は、たまに確実な再起動 (HUP)
    も併用して使った方が良いでしょう。
    これらの問題を克服するのは非常に難しいのですが、
    幸いなことに大部分のアーキテクチャではスコアボードのファイルは必要ありません。
    これを使用するアーキテクチャは、
    <code class="directive"><a href="./mod/mpm_common.html#scoreboardfile">ScoreBoardFile</a></code>
    をご覧下さい。</p>

    <p>全てのアーキテクチャにおいて、個々の子プロセスで
    継続的な HTTP コネクション (KeepAlive)
    に関する小さな競合状態が起こりえます。
    リクエスト行を読んだ後、そしてリクエストヘッダを読む前に
    子プロセスは終了するかも知れません。
    これに対する修正がありますが 1.2 で修正するには発見が遅すぎました。
    理論的には、これは問題ではありません。
    なぜなら KeepAlive のクライアントは、ネットワーク遅延や
    サーバのタイムアウトなどに備えていなければならないからです。
    実際にも何か影響があるようには見えません
    -- テストケースでサーバを 1 秒間に 20 回再起動しても
    クライアントは壊れた画像や空のドキュメントを受け取ることなく
    正常に閲覧できています。</p>
</div></div><div id="footer"><p class="apache">Maintained by the <a href="http://httpd.apache.org/docs-project/">Apache HTTP Server Documentation Project</a></p><p class="menu"><a href="./mod/">モジュール</a> | <a href="./mod/directives.html">ディレクティブ</a> | <a href="./faq/">FAQ</a> | <a href="./glossary.html">用語</a> | <a href="./sitemap.html">サイトマップ</a></p></div></body></html>